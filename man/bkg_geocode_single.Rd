% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bkg_geocode_single.R, R/bkg_reverse_single.R
\name{bkg_geocode_single}
\alias{bkg_geocode_single}
\alias{bkg_reverse_single}
\title{(Reverse) geocoding for a single element}
\usage{
bkg_geocode_single(
  query = NULL,
  street = NULL,
  house_number = NULL,
  zip_code = NULL,
  place = NULL,
  district = NULL,
  street_house = NULL,
  epsg = 3035,
  properties = NULL,
  count = 1L,
  filter = NULL,
  bbox = NULL,
  geometry = NULL,
  relation = "intersects",
  focus_point = NULL,
  radius = 1000L,
  minscore = NULL,
  maxscore = NULL,
  allscores = FALSE,
  interface = c("osgts", "wfs")
)

bkg_reverse_single(location = NULL, poly = NULL, epsg = NULL, count = 1, ...)
}
\arguments{
\item{query}{\code{[character]}

Query term that should be geocoded. Terms can be structured
using a specialized query language. See details. By providing this argument
the GeoSearch endpoint of the BKG geocoder is activated. Otherwise, the
Geocode endpoint will be used that only accepts structured queries using
the arguments below.}

\item{street, house_number, zip_code, place, district, street_house}{\code{[character]}

Address components that should be used for geocoding. At least one of these
arguments has to be provided. \code{street_house} can be provided as an
alternative to street and house_number if these information are tied
together in a single character string. Ignored if \code{query} is not
\code{NULL}}

\item{epsg}{\code{[character/numeric]}

EPSG code of the output coordinate reference system. Does not accept
PROJ4 or WKT strings.}

\item{properties}{\code{[character]}

List of property names to include in the output. \code{text}, \code{type},
\code{score}, and \code{bbox} are always included.}

\item{count}{\code{[numeric]} 

Maximum number of results to return. If \code{> 1}, returns matches in
descending order by BKG score.}

\item{filter}{\code{[character]}

Filter query to narrow the search down based on properties. See details.}

\item{bbox}{\code{[numeric]}

Boundary box to narrow down the search. If provided, only searches for
addresses within the boundary box. Requires the format
\code{c(xmin, ymin, xmax, ymax)}.}

\item{geometry}{\code{[sf/sfc]}

Geometry to narrow down the search. If provided, only searches for addresses
for which the binary predicate specified in \code{relation} is \code{TRUE}.
Ignored if \code{geometry} is \code{NULL}.}

\item{relation}{\code{[character]}

Name of a binary predicate function to test the spatial relationship between
a geocoded point and \code{geometry}. Can be one of \code{intersects},
\code{contains} and \code{disjoint}.}

\item{focus_point}{\code{[sf/sfc]}

Point geometry to narrow down the search. If provided, only searches within
a perimeter specified in \code{radius} around the focus point.}

\item{radius}{\code{[numeric]}

Distance (in meters) from the \code{focus_point}. Results outside of this
radius are not included in the output. Ignored if \code{focus_point} is
\code{NULL}.}

\item{minscore, maxscore}{\code{[numeric]}

Lower and upper threshold of scores to be included. Results with a score
below or above these thresholds are not included in the output.}

\item{allscores}{\code{[logical]}

Whether to return the lowest level of granularity for the geocoding scores.
If \code{TRUE}, returns scores for all address components. Otherwise, only
returns a single score for the whole result.}

\item{interface}{\code{[character]}

Which interface to use for geocoding. Must be one of \code{osgts} or
\code{wfs}. Each interface supports different features, arguments and
properties. Defaults to \code{osgts}}

\item{location}{\code{[sf/sfc]}

A point geometry to be reverse geocoded.}

\item{poly}{\code{[sf/sfc]}

A geometry to be reverse geocoded. Can be a geometry of type \code{POINT},
\code{LINESTRING}, \code{POLYGON}, \code{MULTIPOINT}, \code{MULTILINESTRING},
or \code{MULTIPOLYGON}.}

\item{...}{Further arguments as in \code{bkg_geocode_single} except
query parameters for structured or unstructured geocoding.}
}
\value{
A tibble with a maximum of \code{count} rows and containing the
address matches in descending order by their assigned quality score.
}
\description{
Low-level interface to the OSGTS and WFS geocoding webservices
of the BKG. Fires a single geocoding request at the BKG geocoding
services. Can handle both structured and unstructured geocoding requests.
\code{bkg_geocode_single} takes a query parameter (for unstructured
geocoding) or a set of address elements (for structured geocoding) that
are translated into a point geometry. \code{bkg_reverse_single} takes a
geometry that is translated into an address.
}
\details{
OSGTS requests support a specialized query language, which can be
used to structure term and filter queries. By default, entering a query term
to the \code{query} or \code{filter} arguments is understood as
\code{"text:{term}"}. To further control the output, the BKG geocoder
provides a range of operators to configure the query. For example, a query
could exclude particular places, restrict geocoding to certain states, or
be adjusted to be tolerant towards misspellings.
Query terms support the following operators:

\describe{
  \item{Double quote (\code{""})}{By default, the query language divides a string
  by operators and query terms. Wrapping a term in double quotes allows
  the entry of multiple words.}
  \item{Colon (\code{:})}{Operator used to seperate attribute and term.
  The colon is preceded by an attribute (such as \code{ort} or \code{strasse})
  and succeeded by a term. Defaults to the
  \code{text} attribute. Geocoding searches are restricted to the specified
  attribute-term combinations. For example, \code{"ort:Leipzig"} restricts
  geocoding to addresses within the city of Leipzig.}
  \item{Question mark (\code{?})}{Singular wildcard operator used to replace a
  variable symbol, e.g., \code{"Freib?rg"}.}
  \item{Asterisk (\code{*})}{Multiple wildcard operator used to replace an unknown
  number of variable symbols, e.g. \code{"Frank*"}.}
  \item{Tilde (\code{~})}{Operator to signify an error-tolerant search. Terms that
  precede a tilde are matched based on the Levenshtein edit distance to a
  potential match. The tilde can be preceded by a numeric which represents
  the maximum Levenshtein distance to a match, e.g., \code{"Liepzig~0.6"}.
  
  If a tilde is preceded by a term within double quotes, the numeric
  represents the number of additional words allowed between the phrased
  words, e.g., \code{"\"karl straße\"~1"} means that one additional word can
  be added between karl and straße.}
  \item{Exponent (\code{^})}{Weighting operator. Terms succeeded by an exponent
  operator are weighted based on a numeric behind the operator, e.g.,
  \code{"ort:Leipzig^5.3 typ:Strasse^0.5"} means that it is much more important
  to find an address within Leipzig than it is to find a street.}
  \item{Boolean operators}{Boolean operators include \code{AND}, \code{OR},
  \code{NOT}, \code{+} and \code{-}. They can be used to combine multiple
  query terms. For example, \code{"Leipzig NOT karl-rothe-str"} searches for
  all addresses in Leipzig except for the Karl-Rothe-Straße.}
  \item{Parantheses}{Parantheses are used to group query terms for the use
  with boolean operators. For example,
  \code{"(Leipzig OR Halle) AND typ:Ort"} evaluates Leipzig OR Halle before
  taking into account \code{typ:Ort}.}
  \item{Backslash (\code{\\})}{Can be used to escape operators.}
}
}
\examples{
\dontrun{
# Unstructured geocoding:
bkg_geocode_single("Unter Sachsen* 6-8 AND ort:Köln AND ortsteil:Altstadt")

# Structured geocoding:
bkg_geocode_single(
  street       = "Unter Sachsenhausen",
  house_number = "6-8",
  zip_code     = 50667,
  place        = "Köln",
  epsg         = 3035
)

# Reverse geocoding:
rand_points <- list(
  c(9.162513, 51.02122),
  c(10.24401, 53.58412),
  c(10.56117, 50.50362),
  c(14.46131, 52.19429),
  c(10.62503, 48.31571)
)
rand_points <- sf::st_as_sf(do.call(sf::st_sfc, lapply(rand_points, sf::st_point)))
rand_poly <- aggregate(rand_points, list(rep(1, 5)), function(x){
  sf::st_cast(sf::st_combine(x), "POLYGON")
})
rand_poly <- sf::st_convex_hull(rand_poly)

# Reverse geocoding using a random polygon
bkg_reverse_single(poly = rand_poly, epsg = 3035)

# Reverse geocoding using a random point geometry
bkg_reverse_single(rand_points[1], epsg = 3035, count = 20)
}

}
