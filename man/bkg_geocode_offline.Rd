% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bkg_geocode_offline.R
\encoding{UTF-8}
\name{bkg_geocode_offline}
\alias{bkg_geocode_offline}
\title{Geocoding of a multiple addresses (BKG offline version)}
\usage{
bkg_geocode_offline(
  .data,
  cols = 1L:4L,
  data_from_server = FALSE,
  data_path = "../bkgdata",
  credentials_path = "../bkgcredentials",
  join_with_original = TRUE,
  crs = 3035L,
  identifiers = "rs",
  place_match_quality = 0.8,
  place_match_opts = list(),
  target_quality = 0.8,
  target_opts = list(),
  verbose = TRUE,
  force_decrypt = FALSE
)
}
\arguments{
\item{.data}{\code{[data.frame]}

Dataframe containing address data. The dataframe must contain columns carrying
the street name, house number, zip code and municipality name. The
corresponding column names or indices can be specified using the \code{cols}
argument.}

\item{cols}{\code{[numeric/character]}

Names or indices of the columns containing relevant geocoding information.
Must be of length 3 or 4. If a length-3 vector is passed, the first column is
interpreted as a single character string containing street and house number.
By default, interprets the first four columns as street, house number, zip
code and municipality (in this order).}

\item{data_from_server}{\code{[logical]}

Whether the address data should be downloaded from GESIS internal server?
Requires access to the GESIS net. Defaults to \code{FALSE}.}

\item{data_path}{\code{[character]}

Path to the address data provided by Stefan Jünger. Ignored
if \code{data_from_server = TRUE}.}

\item{credentials_path}{\code{[character]}

Path to credentials package provided by Stefan Jünger.}

\item{join_with_original}{\code{[logical]}

Whether the input data should be joined with the output data. If \code{FALSE},
input data is discarded. Defaults to \code{TRUE}.}

\item{crs}{\code{[various]}

Any kind of object that can be parsed by \code{\link[sf]{st_crs}}
that the output data should be transformed to (e.g. EPSG code, WKT/PROJ4
character string or object of class \code{crs}). Defaults to EPSG:3035.}

\item{identifiers}{\code{[character/logical]}

Territorial identifiers to be included in the output. Can be one or several
of \code{"rs"}, \code{"nuts"} and \code{"inspire"}. \code{"rs"}
is short for Regionalschlüssel and includes all variations of the
official municipality key of Germany. \code{"nuts"} includes all NUTS codes
from NUTS-1 to NUTS-3. \code{"inspire"} includes identifiers for the 100m
and 1km INSPIRE grids. If \code{TRUE}, includes all of the aforementioned
identifiers.}

\item{place_match_quality}{\code{[numeric]}

Targeted quality of second record linkage round (see details). Corresponds to
the (standardized) string metric that can be specified using
\code{target_opts} AND the posterior m-probability that is used to determine
a match during record linkage. Values of 1 are interpreted as \code{1 - 5e-8}
because reclin2 does not support scores that equal 1.}

\item{place_match_opts}{\code{[list]}

Named list that holds further parameters to customize the first
round of record linkage. All list elements are passed as arguments to
\code{\link[stringdist]{stringdist}}. Possible values are \code{method},
\code{weight}, \code{q}, \code{p}, and \code{bt}.}

\item{target_quality}{\code{[numeric]}

Targeted quality of second record linkage round (see details). Corresponds to
the (standardized) string metric that can be specified using
\code{target_opts}.}

\item{target_opts}{\code{[list]}

Named list that holds further parameters to customize the second
round of record linkage. All list elements are passed as arguments to
\code{\link[stringdist]{stringdist}}. Possible values are \code{method},
\code{weight}, \code{q}, \code{p}, and \code{bt}.}

\item{verbose}{\code{[logical]}

Whether to print informative messages and progress bars during
the geocoding process.}

\item{force_decrypt}{\code{[logical]}

Whether to force the function to read in the encrypted
files. This can be useful, if the BKG data should not be stored locally for
too long or if the cached data are corrupt or outdated.}
}
\value{
Returns a nested list of class GeocodingResults containing an
\code{sf} dataframe of the geocoding results (\code{$geocoded}) as well
as a dataframe with addresses with non-matched places (\code{$not_geocoded}),
addresses that didn't pass the first round of record linkage
(\code{$not_place_matched}) and the names of non-matched places
(\code{$unmatched_places}). The object also includes a call object and
descriptive summary statistics. Please note that original columns
retrieve the suffix \code{"_input"}.
}
\description{
Geocoding of a multiple addresses using record linkage and an
address/coordinate database (provided by the BKG)
}
\details{
The function first matches the zip code and place information from
the data against the official names in the address/geocoordinate database
(first round of record linkage). This is done to filter out address datasets
that are not needed and lower the data size. You can play with the quality by
adjusting the \code{place_match_quality} parameter. In a second step, the
input addresses together with the matched results are then again matched
against the addresses in the address/geocoordinate database (second round of
record linkage). Again, you can play with the quality by adjusting
the \code{target_quality} parameter.

Record linkage is employed using string distance metrics from
\code{\link[stringdist]{stringdist}}. By default, scores for both place
matching and geocoding are calculated using the standard Jaro distance. This
metric can be adjusted by passing a list of options that is then passed on
to \code{\link[stringdist]{stringdist}}. This can include the method of
choice \code{method} as well as further method-specific parameters like
the size of the q-gram (\code{q}), the Jaro-Winkler prefix factor (\code{p}),
and the Winkler boost threshold (\code{bt}). To derive a distance index that
falls between 0 and 1, where 0 denotes a complete dissimilarity between both
address strings and 1 denotes a complete similarity, certain edit and q-gram
distance metrics are devided by their maximum possible value as explained in
van der Loo (2014).
For more details on the method
choice, refer to the \code{\link[stringdist]{stringdist-metrics}}
documentation from the \code{stringdist} package.

The overall quality of the geocoding can be evaluated by looking at the
values of the column \code{score} (ranging from 0 to 1), which is based on
the second round of record linkage. In general, for both rounds of record
linkage, a score of above 0.9 can be considered a good match. If the score
falls below 0.8, the result might be questionable.

Address data loading works using a temporary cache. Before trying to request
and decrypt encrypted data chunks, the function will look for each place
dataset in a directory named \code{bkg_data_cache} in \code{tempdir()}. If
found, data decrypting will be skipped for the respective place which can
shorten the processing time significantly for large input datasets with a
high number of different places. If needed, this behavior can be suppressed
by setting \code{force_decrypt = TRUE}.
}
\examples{
data(commaddr, package = "bkggeocoder")

# Basic call with lower quality thresholds
gc <- bkg_geocode_offline(commaddr, cols = 2:5, place_match_quality = 0.7, target_quality = 0.7)

# Geocoding with different string metrics for address matching
gc <- bkg_geocode_offline(commaddr, cols = 2:5, target_opts = list(method = "lv", weight = c(2, 2, 4)))

# Geocoding results are transformed to geographic coordinates
gc <- bkg_geocode_offline(commaddr, cols = 2:5, crs = 4314)

# `cols` argument depends on where the relevant address information is stored
commaddr <- commaddr[, 2:5]
gc <- bkg_geocode_offline(commaddr, cols = 1:4)

# If `cols` is of length 3, street and house_number are assumed to be in a
# single string
commaddr[, "addr.street"] <- paste(commaddr[["addr.street"]], commaddr[["addr.housenumber"]])
gc <- bkg_geocode_offline(commaddr, cols = c("addr.street", "addr.postcode", "addr.city"))

}
\references{
van der Loo, M. P. J. (2014). The stringdist Package for
Approximate String Matching. The R Journal, 6(1), 111–122. https://doi.org/10.32614/RJ-2014-011
}
